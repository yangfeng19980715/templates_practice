//
// Created by yangfeng on 2022/8/1.
//

#include "../headers.h"

/*
动态多态 VS 静态多态
  让我们来对这两种多态性形式进行分类和比较。
  术语
  Static 和 dynamic 多态提供了对不同 C++编程术语的支持：
     通过继承实现的多态是有界的（bounded）和动态的（dynamic）：
       有界的意思是，在设计公共基类的时候，
          参与到多态行为中的类型的相关接口就已经确定（该概念的其它一些术语是侵入的（invasive 和 intrusive））。
       动态的意思是，接口的绑定是在运行期间执行的。
      
     通过模板实现的多态是无界的（unbounded）和静态的（static）：
       无界的意思是，参与到多态行为中的类型的相关接口是不可预先确定的（该概念的
          其它一些术语是非侵入的（noninvasive 和 nonintrusive））
       静态的意思是，接口的绑定是在编译期间执行的。
      
    因此，严格来讲，在 C++中，动态多态和静态多态分别是有界动态多态和无界静态多态的缩写。
     在其它语言中还会有别的组合（比如在 Smakktalk 中的无界动态多态）。
     但是在 C++语境中，更简洁的动态多态和静态多态也不会带来困扰。
     
  优点和缺点
  C++中的动态多态有如下优点：
     可以很优雅的处理异质集合。
     可执行文件的大小可能会比较小（因为它只需要一个多态函数，不像静态多态那样，需要为不同的类型进行各自的实例化）。
     代码可以被完整的编译；因此没有必须要被公开的代码（在发布模板库时通常需要发布模板的源代码实现）。
    
  作为对比，下面这些可以说是 C++中 static 多态的优点：
     内置类型的集合可以被很容易的实现。更通俗地说，接口的公共性不需要通过公共基类实现。
     产生的代码可能会更快（因为不需要通过指针进行重定向，先验的（priori）非虚函数通常也更容易被 inline）。
     即使某个具体类型只提供了部分的接口，也可以用于静态多态，只要不会用到那些没有被实现的接口即可。
    
  通常认为静态多态要比动态多态更类型安全（type safe），因为其所有的绑定都在编译期间进行了检查。
  例如，几乎不用担心将一个通过模板实例化得到的、类型不正确的对象插入到一个已有容器中（编译期间会报错）。
  但是，对于一个存储了指向公共基类的指针的容器，其所存储的指针却有可能指向一个不同类型的对象。
  
  在实际中，当相同的接口后面隐藏着不同的语义假设时，模板实例化也会带来一些问题。
  比如，当关联运算符 operator +被一个没实现其所需的关联操作的类型实例化时，就会遇到错误。
  在实际中，对于基于继承的设计层次，很少会遇到这一类的语义不匹配，这或许是因为相应的接口规格得到了较好的说明。
  
  结合两种多态形式
    当然，我们也可以结合这两种多态形式。
    比如，为了能够操作集合对象的异质集合，你可以从一个公共基类中派生出不同的集合对象。
    而且，你依然可以使用模板为某种形式的集合对象书写代码。
    
    在第 21 章会更详细地讨论继承和模板的结合问题。
     我们会看到，一个成员函数的虚拟性是如何被参数化的，
      以及我们是如何通过 curiously recurring template pattern（CRTP）为 static 多态提供额外的灵活性的。
 */

using namespace std;

namespace ch18_3 {

  namespace case1 {
  }
  
  namespace case2 {
  }
  
  namespace case3 {
  }
  
  namespace case4 {
  }
  
  namespace case5 {
  
  }

  class Tmp {
  public:
  
  };

}

int
//main()
main_Dynamic_versus_Static_Polymorphism_18_3()
{

  return 0;
}