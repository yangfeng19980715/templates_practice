//
// Created by yangfeng on 2022/8/11.
//

#include "../headers.h"

using namespace std;
/*
19.10 在标准库中的情况
  在 C++11 中，类型萃取变成了 C++标准库中固有的一部分。它们或多或少的构成了在本章中
  讨论的所有的类型函数和类型萃取。但是，对于它们中的一部分，比如个别的操作探测，以
  及有过讨论的 std::is_union，目前都还没有已知的语言解决方案。而是由编译器为这些萃取
  提供了支持。同样的，编译器也开始支持一些已经由语言本身提供了解决方案的萃取，这主
  要是为了减少编译时间。
  因此，如果你需要类型萃取，我们建议在可能的情况下都尽量使用由 C++标准库提供的萃取。
  在附录 D 中对它们有详细的讨论。
  需要注意的是，某些萃取的行为可能会让人很意外（至少对于新手程序员）。除了我们在第
  11.2.1 节和第 D.1.2 节暗示过的东西，也请参考我们在附录 D 中给出的相关描述。
  C++标准库也定义了一些策略和属性萃取：
   类模板 std::char_traits 被 std::string 和 I/O stream 当作策略萃取使用。
  
  为 了 将 算 法 简 单 的 适 配 于 标 准 迭 代 器 的 种 类 ， 标 准 库 提 供 了 一 个 很 简 单 的
  std::iterator_traits 属性萃取模板。
  
  模板 std::numeric_limits 作为属性萃取模板也会很有帮助。
  
  最后，为标准库容器类型进行的内存分配是由策略萃取类处理的（参见 std::shared_ptr
  的实现）。从 C++98 开始，标准库专门为了这一目的提供了 std::allocator 模板。从 C++11
  开始，标准库引入了 std::allocator_traits 模板，这样就能够修改内存分配器的策略或者
  行为了。
  
19.11 后记
  Nathan Myers 是第一个提出萃取参数这一概念的人。他最初将该想法作为在标准库组件中定
  义处理类型的方式提交给 C++标准委员会。在当时，他称其为 baggage templates，并注意到
  它们包含了萃取。但是，C++委员会的一部分成员不喜欢 baggage 这个名字，并最终促成了
  traits 这一名字的使用。后者在那之后被广泛使用。
  客户代码通常不会和萃取有任何交集：默认萃取类的行为满足了大部分的常规需求，而且由
  于它们是默认模板参数，它们根本就不需要出现在客户代码中。这有利于为默认萃取模板使
  用很长的名字。当客户代码通过提供客制化的萃取参数适应了模板的行为后，最好能够为最
  终的特化提供一个类型别名。
  萃取可以被作为一种反射（reflection）使用，在其中程序看到了其自身的更为高阶的属性。
  诸如 IsClassT 和 PlusResult 的萃取，以及其它一些窥测了程序中类型的类型萃取，都实现了
  一种编译期的反射，这被证明是元编程的一个很好的手段。
  将类型属性作为模板特化成员存储的相反至少可以追溯到 1990 年代中期。一种比较严肃的
  早期的类型分类模板的应用是由 SGI（Silicon Graphics）发布的 STL 实现。SGI 模板被用来代
  表其模板参数的一些属性。这些信息又被用来为特定的类型进行 STL 算法优化。
  Boost 提供了更为完整的一组类型分类模板，它们构成了 2011C++标准库中<type_triats>的基
  础。虽然其中一些萃取可以根据本章介绍的技术实现，其它一些却需要编译器的支持，这一
  点和由 SGI 编译期提供的__type_traits 特化实现很类似。
  使用诸如 isValid 的泛型模板提取 SFINAE 条件的本质信息这一技术是由 Louis Dionne 在 2015
  年提出的，并在 Boost.Hana 中得到应用。
  策略类显然是由很多程序员一起开发的，但是其中只有一部分得到了署名。Andrei
  Alexandrescu 使 policy classes 这一名词变得流行，他在其《Modern C++ Design》中对其有更
  为详细的介绍。
 */

namespace ch19_10 {

  namespace case1 {
  }
  
  namespace case2 {
  }
  
  namespace case3 {
  }
  
  namespace case4 {
  }
  
  namespace case5 {
  
  }

  class Tmp {
  public:
  
  };

}

int
//main()
main_In_the_Standard_Library_19_10()
{

  return 0;
}