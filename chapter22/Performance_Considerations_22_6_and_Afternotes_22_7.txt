22.6 性能考量
类型擦除技术提供了 static 和 dynamic 多态的一部分优点，但是并不是全部。尤其是，使用
类型擦除技术产生的代码的性能更接近于动态多态，因为它们都是用虚函数实现了动态分
配。因此某些 static 多态的传统优点（比如编译期将函数调用进行 inline 的能力）可能就被
丢掉了。这一性能损失是否能够被察觉到，取决于具体的应用，但是通过比较被调用函数的
运算量以及相关虚函数的运算量，有时候也很容易就能判断出来：如果二者比较接近，（比
如 FunctionPtr 所作的只是对两个整数进行求和），类型擦除可能会比 static 多态要满很多。
而如果函数调用执行的任务量比较大的话（比如访问数据库，对容器进行排列），那么 type
erasure 带来的性能损失就很难被察觉到。

22.7 后记
通过引入 any 类型，Kevlin Henney 使得类型擦除在 C++中变得流行起来，随后演变成 Boost
中一个流行的库，以及 C++17 标准库的一部分。该技术在 Boost.Function 库中得到优化（主
要是进行了性能和代码量的优化），并最终变成了 std::function<>。但是之前所有的库都只
解决了一组操作相关的问题：任何只有 copy 和 case 操作的简单类型，函数都可以对其进行
调用。
随后的一些工作，比如 Boost.TypeErasue 库以及 Adobe 的 Poly 库，通过使用模板元编程技术，
让用户可以生成一个支持某些特定操作的、被擦除了类型的值。比如下面的类型（通过
Boost.TypeErase 库构建）就支持拷贝构造，类似 typeid 的操作，以及输出用来打印的输出
stream：
using AnyPrintable = any<mpl::vector<copy_constructible<>, typeid_<>,
ostreamable<> >>;